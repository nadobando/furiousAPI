{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the official documentation for <code>FuriousAPI</code>.</p> <p>FastAPI \u2764\ufe0f  FuriousAPI</p>"},{"location":"#what-is-furiousapi","title":"What is FuriousAPI?","text":"<p>Just as the name playfully suggests a connection to the high-octane Fast &amp; Furious movie series \ud83e\udd2d</p> <p>FuriousAPI aims to accelerate FastAPI development with additional features and conveniences.</p> <p>FuriousAPI is inspired by the Django REST Framework (DRF) and aims to bring the best practices and design patterns of DRF into the asynchronous world of FastAPI.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Class Based Views: Introduces class-based views with mixins to FastAPI, making your code more reusable and   maintainable.</li> <li>ModelController or ModelView: Introduces model-based views to FastAPI, making the CRUD in just few lines of code</li> <li>Cursor/Relay/Offset Pagination: Introduces Pagination abstractions to be used by other extensions</li> <li>Enhance Code Reuse and Standard</li> <li>Designed for Extensibility: FuriousAPI provides a solid foundation, which can be extended with plugins   like:<ul> <li><code>furiousapi-sqlmodel</code> for SQL databases.</li> <li><code>furiousapi-beanie</code> for MongoDB.</li> </ul> </li> <li>Asynchronous Capabilities: Integrates seamlessly with FastAPI to take full advantage of modern Python's async and   await features.</li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>FuriousAPI is built with the following principles in mind:</p> <ul> <li>Extensible: Just like DRF, FuriousAPI offers multiple extension points so you can plug in your functionality or   integrate with other libraries and frameworks.</li> <li>Framework-agnostic: FuriousAPI can be used with any Python DB framework, providing flexibility and freedom in   choosing your tools.</li> <li>Speed and Performance: Embracing the async nature of FastAPI for non-blocking I/O operations.</li> <li>Flexibility and Extensibility: Offering a range of extensions to fit various data storage and processing   requirements.</li> <li>Expressive and Clear Syntax: Aiming for an API design that is both intuitive and expressive, making your endpoints   easy to read and write.</li> <li>DRY Principles: Reducing code repetition through mixins and generic classes, promoting reusability and   maintainability.</li> <li>Seamless Integration: Designed to integrate smoothly with FastAPI's ecosystem, allowing for easy adoption within   existing projects.</li> <li>Type Safety and Validation: Utilizes Pydantic models for robust data validation and schema definition, consistent   with FastAPI's standards.</li> <li>Ease of Use: Developers can quickly create APIs with sensible defaults and powerful configuration options.</li> <li>Extensibility: Core components are designed to be extended or replaced to fit the needs of any project.</li> <li>DRF's Design Patterns: Brings DRF's mature design patterns into the FastAPI world, harmonizing Django's simplicity   with FastAPI's performance.</li> <li>DRF-Inspired Design: Adopts the philosophies of DRF, focusing on modular, reusable components and clear, concise   code.</li> <li>Rich Ecosystem: Leverage the power of the FastAPI ecosystem with enhanced capabilities provided by FuriousAPI   extensions.</li> </ul> <p>To begin using FuriousAPI, proceed to the Installation guide. To see how to build a fully-fledged API with FuriousAPI, start with the Tutorial.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions to FuriousAPI are welcome! Here are the guidelines for contributing to the project.</p>"},{"location":"installation/","title":"Installation","text":"<p>Installing FuriousAPI is easy and can be customized depending on the extensions you plan to use. Follow these instructions to get started.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing FuriousAPI, ensure that you have:</p> <ul> <li>Python 3.7 or higher</li> <li>A suitable virtual environment manager (like venv or conda)</li> <li>pip for installing Python packages</li> </ul>"},{"location":"installation/#installing-furiousapi","title":"Installing FuriousAPI","text":"<p>To install the core FuriousAPI package, run the following command in your virtual environment:</p> <pre><code>pip install furiousapi\n</code></pre> <p>To use FuriousAPI with SQLModel support, you can install it with the <code>sqlmodel</code> extra:</p> <pre><code>pip install \"furiousapi[sqlmodel]\"\n</code></pre> <p>Similarly, to install FuriousAPI with Beanie (ODM for MongoDB) support:</p> <pre><code>pip install \"furiousapi[beanie]\"\n</code></pre> <p>You can also install both extensions together:</p> <pre><code>pip install \"furiousapi[sqlmodel,beanie]\"\n</code></pre> <p>These commands will download and install FuriousAPI along with the selected extensions and their dependencies.</p>"},{"location":"installation/#post-installation","title":"Post-installation","text":"<p>After installation, you can create your first endpoint using FuriousAPI's class-based views (CBVs) with mixins to add methods as needed.</p>"},{"location":"installation/#upgrading-furiousapi","title":"Upgrading FuriousAPI","text":"<p>To upgrade FuriousAPI and its extensions to the latest versions, use the following command:</p> <pre><code>pip install --upgrade furiousapi\n</code></pre> <p>For extensions, replace <code>furiousapi</code> with the appropriate package name in the command above.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues during the installation:</p> <ul> <li>Verify that you have the correct version of Python installed.</li> <li>Ensure that your pip is up-to-date.</li> <li>Check any error messages during the installation process and look them up in the Support section.</li> </ul> <p>For more detailed instructions, including advanced configurations and environment setup, refer to the Advanced Installation section in the Advanced Guide.</p>"},{"location":"license/","title":"License","text":"<p>FuriousAPI is licensed under the MIT License. See the LICENSE file for more details.</p>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Install FuriousAPI and extend your FastAPI project with the power of DRF's design patterns:</p> <pre><code>pip install fastapi furiousapi\n</code></pre> <p>To include database support, pick the extension that suits your needs:</p> <pre><code>pip install \"furiousapi[sqlmodel]\" # For SQLModel integration\npip install \"furiousapi[beanie]\"   # For MongoDB with Beanie\n</code></pre> <p>Define a model and create a <code>ModelController</code> to handle API interactions:</p> <pre><code>from typing import Annotated\n\nimport uvicorn\nfrom fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlmodel import SQLModel, Field\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom furiousapi.api import ModelController\nfrom furiousapi.sqlmodel import SQLRepository\n\n# app_dependencies.py\nengine = create_async_engine(\"sqlite+aiosqlite:///test_db.sqlite\")\n\n\nasync def sql_session() -&gt; AsyncSession:\n    async with AsyncSession(engine, expire_on_commit=False) as session:\n        yield session\n\n\nSessionDep = Annotated[AsyncSession, Depends(sql_session)]\n\n\n# items/models.py\nclass Item(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    description: str = Field(default=None, nullable=True)\n\n\n# items/repository.py\nclass ItemRepository(SQLRepository[Item]):\n    pass\n\n\n# items/dependencies.py\ndef repository(session: SessionDep) -&gt; ItemRepository:\n    return ItemRepository(session)\n\n\n# routes.py\nclass ItemController(ModelController, prefix=\"/item\", tags=[\"Items\"]):\n    repository = Depends(repository)\n\n\n# app.py\napp = FastAPI()\napp.include_router(ItemController.api_router)\n\nif __name__ == '__main__':\n    uvicorn.run(app)\n</code></pre> <p>This sets up a basic CRUD API for the <code>Item</code> model with minimal code. </p>"},{"location":"quickstart/#get","title":"Get","text":""},{"location":"quickstart/#create","title":"Create","text":""},{"location":"quickstart/#update","title":"Update","text":""},{"location":"quickstart/#delete","title":"Delete","text":""},{"location":"quickstart/#list","title":"List","text":"<p>For detailed instructions and best practices, visit our Tutorial section.</p>"},{"location":"release_notes/","title":"Release Notes","text":"<p>This section lists the release notes for each version of FuriousAPI.</p>"},{"location":"support/","title":"User &amp; Developer Support","text":"<p>Find out how to get support for FuriousAPI, whether through community forums, professional support, or the issue tracker.</p>"},{"location":"topics/","title":"Topics","text":"<p>Here we discuss various advanced topics such as integration with databases, asynchronous processing, and more.</p>"},{"location":"tutorial/","title":"Tutorial: Building Your First API with FuriousAPI","text":"<p>In this tutorial, you will learn how to build a more comprehensive API with FuriousAPI. We'll expand on the Quick Start guide by adding more functionality to our <code>Item</code> model.</p>"},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<p>Before starting this tutorial, you should have:</p> <ul> <li>Completed the Quick Start guide.</li> <li>Basic understanding of Python and FastAPI.</li> <li>FuriousAPI installed in your virtual environment.</li> </ul>"},{"location":"tutorial/#step-1-expand-your-model","title":"Step 1: Expand Your Model","text":"<p>Let's add more fields to our <code>Item</code> model to make it more interesting.</p> <pre><code># models.py\nfrom sqlmodel import SQLModel, Field\n\nclass Item(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    description: str = Field(default=None, nullable=True)\n    price: float = Field(default=0)\n    is_available: bool = Field(default=True)\n</code></pre>"},{"location":"tutorial/#step-2-enhance-your-repository","title":"Step 2: Enhance Your Repository","text":"<p>Update your repository to handle more complex queries.</p> <pre><code># repository.py\nfrom furiousapi.sqlmodel import SQLRepository\nfrom .models import Item\n\n\nclass ItemRepository(SQLRepository[Item]):\n\n    async def set_item_availability(self, id_: int, status: bool):\n        item = await self.get(id_)\n        item.is_available = status\n        self.session.add(item)\n        await self.session.commit()\n</code></pre>"},{"location":"tutorial/#step-3-update-the-controller","title":"Step 3: Update the Controller","text":"<p>Modify your <code>ItemController</code> to use the new repository methods.</p> <pre><code># controllers.py\nimport http\nfrom fastapi import Depends, Path\nfrom furiousapi.api import ModelController, action\nfrom repository import ItemRepository\n\n\nclass ItemController(ModelController, prefix=\"/item\", tags=[\"Items\"]):\n    repository = Depends(ItemRepository)\n\n    @action(\"/{id}/set-availability/{status}\", methods=[http.HTTPMethod.POST])\n    async def get_available_items(self, id_=Path(alias=\"id\"), status: bool = Path()):\n        return await self.repository.set_item_availability(id_, status)\n</code></pre>"},{"location":"tutorial/#step-4-test-your-api","title":"Step 4: Test Your API","text":"<p>With your API updated, it's time to test the new functionality. Use tools like <code>httpx</code> or Postman to make requests to your endpoints and ensure everything works as expected.</p>"},{"location":"tutorial/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've just expanded your API to handle more complex data and secured it with basic authentication. As you continue to develop with FuriousAPI, remember to refer to the documentation for guidance on more advanced features and best practices.</p>"},{"location":"api_guide/","title":"API Guide for FuriousAPI","text":"<p>Welcome to the API Guide for FuriousAPI. This section provides detailed instructions on building and fine-tuning your API with FuriousAPI. Each guide is tailored to help you understand and implement specific features of FuriousAPI effectively.</p>"},{"location":"api_guide/#overview","title":"Overview","text":"<p>FuriousAPI is designed to enhance the FastAPI experience by offering a robust set of tools that streamline the development of APIs. It borrows the best practices from Django REST Framework and adapts them for the asynchronous world of FastAPI, bringing in a familiar yet powerful approach to API construction.</p>"},{"location":"api_guide/#topics","title":"Topics","text":"<ul> <li> <p>Error Handling: Gracefully manage and return errors from your API.</p> </li> <li> <p>Views: Explore the use of class-based views and mixins for handling common API actions.</p> </li> </ul>"},{"location":"api_guide/#getting-started","title":"Getting Started","text":"<p>If you are new to FuriousAPI, we recommend starting with the Installation guide, followed by the step-by-step instructions in the Tutorial to create your first API.</p>"},{"location":"api_guide/#feedback-and-contributions","title":"Feedback and Contributions","text":"<p>We value your feedback and contributions. If you encounter any issues or have suggestions for improvements, please refer to the Contributing guide for details on how to get involved.</p> <p>Thank you for choosing FuriousAPI to build your APIs. We are excited to see what you will build!</p>"},{"location":"api_guide/beanie/","title":"Beanie Integration with FuriousAPI","text":"<p>Beanie is an asynchronous ODM (Object-Document Mapper) for MongoDB, built on top of Motor. In <code>FuriousAPI</code>, the <code>furiousapi-beanie</code> extension integrates Beanie to provide a seamless experience when working with MongoDB.</p>"},{"location":"api_guide/beanie/#repository-pattern-with-beanie","title":"Repository Pattern with Beanie","text":"<p>The repository pattern in <code>FuriousAPI</code> abstracts away the data access layer. With the <code>furiousapi-beanie</code> extension, this pattern is implemented for MongoDB using Beanie. This allows for a consistent CRUD interface and query capabilities, abstracting away the specifics of MongoDB access.</p>"},{"location":"api_guide/beanie/#setting-up-a-beanie-repository","title":"Setting up a Beanie Repository","text":"<p>To set up a Beanie repository in <code>FuriousAPI</code>, you need to define a model using Beanie's <code>Document</code> class and then create a repository class that extends <code>BeanieRepository</code>. The repository class will handle the data operations for the model.</p> <pre><code>from typing import Optional\n\nfrom beanie import Document, init_beanie\nfrom fastapi import FastAPI, Depends\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\n\nfrom furiousapi.beanie import MongoRepository\nfrom furiousapi.api import ModelController\n\n\n# Define your Beanie document\nclass Item(Document):\n    name: str\n    description: Optional[str] = None\n\n\n# Extend MongoRepository to create your repository class\nclass ItemRepository(MongoRepository[Item]):\n    pass\n\n\n# Use the ItemRepository with a ModelController\nclass ItemController(ModelController):\n    repository = Depends(ItemRepository)\n\n\napp = FastAPI()\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    client = AsyncIOMotorClient()\n    database = AsyncIOMotorDatabase(client, \"app\")\n    await init_beanie(database, document_models=[Item])\n\n\napp.include_router(Item)\n</code></pre>"},{"location":"api_guide/beanie/#integrating-with-modelcontroller","title":"Integrating with ModelController","text":"<p>Once you have your Beanie repository set up, you can integrate it with <code>ModelController</code> to provide a fully functional API interface for your MongoDB documents.</p>"},{"location":"api_guide/beanie/#async-operations","title":"Async Operations","text":"<p>All operations in the Beanie repository are asynchronous, leveraging Python's async and await features for non-blocking I/O operations with MongoDB.</p>"},{"location":"api_guide/beanie/#conclusion","title":"Conclusion","text":"<p>The <code>furiousapi-beanie</code> extension offers a powerful way to integrate MongoDB with your <code>FuriousAPI</code> projects, harnessing the repository pattern for clean, maintainable code that abstracts away database access.</p> <p>For more detailed examples and advanced configurations, refer to the <code>Beanie</code> documentation and the <code>furiousapi-beanie</code> extension guide.</p>"},{"location":"api_guide/cbv/","title":"Class Based Views","text":""},{"location":"api_guide/cbv/#class-based-view-routing","title":"Class Based View Routing","text":"<p>The core of FuriousAPI routing is built on FastAPI's powerful router. Here's how you can define basic routes:</p>"},{"location":"api_guide/cbv/#defining-a-class-based-view","title":"Defining a Class Based View","text":"<pre><code>from http import HTTPMethod\nfrom fastapi import FastAPI, Depends\nfrom furiousapi.api import CBV\nfrom furiousapi.api.controllers import mixins\n\nfrom .dependencies import Dependency, dependency1\n\napp = FastAPI()\n\n\n# here you can add APIRouter parameters\nclass MyView(CBV, mixins.GetRouteMixin, mixins.PostRouteMixin, prefix=\"/some-prefix\"):\n    # configure the FastAPI route\n    __route_config__ = {\n        HTTPMethod.GET: {\n            \"response_model_exclude\": {\"some_field_to_exclude\"}\n        }\n\n    }\n    # you can add here FastAPI dependencies so they will be available in the function via `self.`\n    dependency1 = Depends(dependency1)\n\n    def get(self, another_dependency: Dependency) -&gt; str:\n        ...\n        self.dependency1.do_foo()\n        another_dependency.do_second_foo()\n        return \"\"\n\n    def post(self, another_dependency: Dependency) -&gt; str:\n        ...\n        self.dependency1.do_foo()\n        another_dependency.do_second_foo()\n        return \"\"\n</code></pre>"},{"location":"api_guide/cbv/#adding-action-to-classbasedviews","title":"Adding <code>@action</code> to ClassBasedViews","text":"<pre><code>from http import HTTPMethod\nfrom fastapi import Path\nfrom furiousapi.api import CBV, action\nfrom furiousapi.api.controllers import mixins\nfrom .dependencies import Dependency\n\n\n# here you can add APIRouter parameters\nclass MyView(CBV, mixins.GetRouteMixin, mixins.PostRouteMixin, prefix=\"/some-prefix\"):\n\n    @action(\"/an-action-path/{param1}\", methods=[HTTPMethod.POST])\n    def do_special_foo(self, another_dependency: Dependency, param1=Path()) -&gt; str:\n        ...\n</code></pre>"},{"location":"api_guide/cbv/#using-existing-fastapiapirouter-in-class-based-views","title":"Using existing <code>fastapi.APIRouter</code> in Class Based Views","text":"<p>this can be useful for nesting</p> <pre><code>from fastapi import APIRouter\n\nrouter = APIRouter()\n\n\nclass MyView(CBV, mixins.GetRouteMixin, mixins.PostRouteMixin):\n    api_router = router\n</code></pre>"},{"location":"api_guide/error_handling/","title":"Error handling","text":"<pre><code>from fastapi import FastAPI\n\nfrom furiousapi.db import FuriousEntityError\nfrom furiousapi.api.exception_handling import furious_exception_handler\n\napp = FastAPI()\napp.add_exception_handler(FuriousEntityError, furious_exception_handler)\n</code></pre>"},{"location":"api_guide/model_controller/","title":"ModelController","text":""},{"location":"api_guide/model_controller/#modelcontroller","title":"ModelController","text":"<p>FuriousAPI's <code>ModelController</code> is a powerful abstraction built on top of the <code>CBV</code> (Class-Based View), designed to streamline interactions with data models for CRUD operations and beyond, while minimizing the need for repetitive boilerplate code. It inherits all the benefits of <code>CBV</code> and extends them with model-specific capabilities.</p>"},{"location":"api_guide/model_controller/#defining-a-modelcontroller","title":"Defining a ModelController","text":"<p>A <code>ModelController</code> is defined by extending the <code>ModelController</code> base class, which itself inherits from <code>CBV</code>. This setup provides a structured approach to building API endpoints, emphasizing reuse and maintainability. Here's how you can define a <code>ModelController</code>:</p>"},{"location":"api_guide/model_controller/#requirements","title":"Requirements","text":"<p>in order to be able to use the <code>ModelController</code> you need to define the <code>repository</code> FastAPI dependency</p> <pre><code>from fastapi import Depends\nfrom furiousapi.api import ModelController\nfrom .repository import ItemRepository\n\n\n# Define the ModelController\nclass ItemController(ModelController):\n    # as the CBV, dependencies can be added\n    repository = Depends(ItemRepository)\n\n    # Optionally, override default methods or add new endpoints\n    # ...\n</code></pre> <p>By inheriting from <code>CBV</code>, <code>ModelController</code> allows for the organization of request handling logic in a class-based structure, enabling more complex compositions and reuse of common functionality.</p>"},{"location":"api_guide/model_controller/#customizing-endpoints-with-action","title":"Customizing Endpoints with <code>@action</code>","text":"<p>The <code>ModelController</code> can be further customized with the <code>@action</code> decorator to define custom actions, adding an extra layer of functionality to the endpoints:</p> <pre><code>from http import HTTPMethod\nfrom fastapi import Depends\nfrom furiousapi.api import ModelController, action\nfrom .repository import ItemRepository\n\n\nclass ItemController(ModelController):\n    # ...\n\n    @action(\"/sold\", methods=[HTTPMethod.PATCH])\n    async def mark_as_sold(self, id_: int):\n        # Implement custom logic to mark an item as sold\n        pass\n</code></pre> <p>The <code>@action</code> decorator enhances the expressiveness of the <code>ModelController</code>, giving you the ability to specify actions on both detail and list routes and to respond to various HTTP methods.</p>"},{"location":"api_guide/model_controller/#integrating-with-fastapis-routing","title":"Integrating with FastAPI's Routing","text":"<p><code>ModelController</code> is designed to integrate smoothly with FastAPI's routing, allowing you to easily include its routes in your FastAPI application:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\nitem_controller = ItemController()\n\n# Include the controller's routes into the FastAPI app\napp.include_router(item_controller.api_router)\n</code></pre> <p>By integrating <code>ModelController</code> into your FastAPI application, you expose a suite of endpoints that encapsulate CRUD operations and any additional actions you've defined, following RESTful principles and best practices.</p>"},{"location":"api_guide/pydangorm/","title":"PydangORM","text":"<p>pydangorm is a robust and user-friendly asynchronous ORM (Object-Relational Mapping) system tailored for ArangoDB, a powerful multi-model NoSQL database.</p>"},{"location":"api_guide/pydangorm/#coming-soon","title":"Coming Soon","text":""},{"location":"api_guide/repository/","title":"Repository","text":"<p>The <code>FuriousAPI</code> embraces the repository pattern as a central design principle, abstracting the data access layer and making it agnostic to the specific ORM/ODM used. This abstraction allows <code>ModelController</code> to be flexible and extensible while providing a uniform interface for CRUD operations and more complex data manipulations.</p>"},{"location":"api_guide/repository/#repository-configuration","title":"Repository Configuration","text":"<p>The <code>Repositoryonfig</code> class allows developers to define specific configurations that apply to data access, such as fields to include or exclude in responses, sorting options, and pagination settings. These configurations are then utilized by the <code>ModelController</code> to interact with the underlying data model in a consistent way.</p> <pre><code>class RepositoryConfig:\n    fields_include: ClassVar[Optional[Set[str]]] = None\n    fields_exclude: ClassVar[Optional[Set[str]]] = None\n    sort_include: ClassVar[Optional[Set[str]]] = None\n    sort_exclude: ClassVar[Optional[Set[str]]] = None\n    default_limit: ClassVar[int] = get_settings().pagination.default_size\n    max_limit: ClassVar[int] = get_settings().pagination.max_size\n    model_to_query: ClassVar[ModelDependency]\n    filter_model: ClassVar[ModelMetaclass]\n</code></pre> <p>The settings within <code>RepositoryConfig</code> are used to construct the repository's behavior. This includes the fields and sorting options that are allowed, the pagination defaults, and the models used for querying and filtering.</p> <ul> <li>fields_include: which fields will be included from the model and be able to be requested as the <code>fields</code></li> <li>fields_exclude: which fields will be excluded from the model and be able to be requested as the <code>fields</code></li> <li>sort_include: which fields will be sortable</li> <li>sort_exclude: which fields will be excluded from sortable enum</li> <li>default_limit: default pagination size</li> <li>max_limit: max pagination size</li> <li>model_to_query: how the model is processed as FastAPI dependency</li> <li>filter_model: currently converts all fields in a model to optional</li> </ul> <pre><code>class ItemRepository(SQLRepository[Item]):\n    class Config(RepositoryConfig):\n        default_limit = 100\n        sort_include = (\"id\", \"name\")\n</code></pre>"},{"location":"api_guide/repository/#repository-and-modelcontroller-integration","title":"Repository and ModelController Integration","text":"<p>The repository in <code>FuriousAPI</code> is tightly coupled with <code>ModelController</code>. The <code>ModelController</code> is dependent on a repository to define how it operates. The meta-class <code>RepositoryMeta</code> dynamically attaches the model, sorting, fields, and filtering configurations based on the repository's <code>Config</code> class.</p> <ul> <li>SQLModel Integration</li> <li>Beanie Integration</li> <li>PydangoORM (arangoDB) Integration</li> </ul>"},{"location":"api_guide/sqlmodel/","title":"SQLModel Integration with FuriousAPI","text":"<p>SQLModel is a library that bridges SQL databases with Python models using SQLAlchemy for database operations and Pydantic for data validation. FuriousAPI leverages SQLModel to provide an ORM layer that is both powerful and easy to use. the <code>furiousapi-sqlmodel</code> extension integrates SQLModel to provide a seamless experience when working with SQL.</p>"},{"location":"api_guide/sqlmodel/#repository-pattern-with-sqlmodel","title":"Repository Pattern with SQLModel","text":"<p>The repository pattern in <code>FuriousAPI</code> abstracts away the data access layer. With the <code>furiousapi-sqlmodel</code> extension, this pattern is implemented for SQL using SQLModel. This allows for a consistent CRUD interface and query capabilities, abstracting away the specifics of SQL access.</p>"},{"location":"api_guide/sqlmodel/#setting-up-an-sqlmodel-repository","title":"Setting up an SQLModel Repository","text":"<p>To set up a SQLModel repository in <code>FuriousAPI</code>, you need to define a model using SQLModel's <code>SQLModel</code> class and then create a repository class that extends <code>SQLRepository</code>. The repository class will handle the data operations for the model.</p> <pre><code>from typing import Annotated\n\nimport uvicorn\nfrom fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlmodel import SQLModel, Field\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom furiousapi.api import ModelController\nfrom furiousapi.sqlmodel import SQLRepository\n\n# app_dependencies.py\nengine = create_async_engine(\"sqlite+aiosqlite:///test_db.sqlite\")\n\n\nasync def sql_session() -&gt; AsyncSession:\n    async with AsyncSession(engine, expire_on_commit=False) as session:\n        yield session\n\n\nSessionDep = Annotated[AsyncSession, Depends(sql_session)]\n\n\n# items/models.py\nclass Item(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    description: str = Field(default=None, nullable=True)\n\n\n# items/repository.py\nclass ItemRepository(SQLRepository[Item]):\n    pass\n\n\n# items/dependencies.py\ndef repository(session: SessionDep) -&gt; ItemRepository:\n    return ItemRepository(session)\n\n\n# routes.py\nclass ItemController(ModelController, prefix=\"/item\", tags=[\"Items\"]):\n    repository = Depends(repository)\n\n\n# app.py\napp = FastAPI()\napp.include_router(ItemController.api_router)\n\nif __name__ == '__main__':\n    uvicorn.run(app)\n</code></pre>"}]}